ABCL/c+ Language Specification
==============================

Version: 1.0
Author: Yasushi Kodama
Implementation Language: OCaml
Date: 2025


1. Overview
-----------

ABCL/c+ is an actor-based concurrent programming language
inspired by the Actor model and the ABCL family (ABCL/1, ABCL/R, etc.).
It extends the ABCL syntax with static type checking, polymorphic
type inference, arrays, functions, and an actor-based concurrency model.

The implementation is written in OCaml and consists of:
  - A lexical analyzer (lexer.mll)
  - A parser (parser.mly)
  - An evaluator with actor runtime (eval_thread.ml)
  - A polymorphic Hindley–Milner type inference engine (infer.ml)
  - A typing environment (typing_env.ml)
  - A REPL and compiler front-end (repl_thread.ml)


2. Lexical and Syntax Overview
------------------------------

Basic tokens:
  IDENTIFIER   : [a-zA-Z_][a-zA-Z0-9_]*
  INT          : sequence of digits without '.'
  FLOAT        : digits with a decimal point
  STRING       : " ... "
  KEYWORDS     : class, actor, var, method, send, call, new,
                 if, then, else, while, become, on, true, false

Comments:
  - Single line comment starts with '//'
  - Block comment: /* ... */

Statements:
  VarDecl      ::= 'var' IDENT ['=' Expr] ';'
  Assign       ::= IDENT '=' Expr ';'
  CallStmt     ::= 'call' IDENT '(' [Args] ')' ';'
  SendStmt     ::= 'send' IDENT '.' IDENT '(' [Args] ')' ';'
  Seq          ::= Stmt { Stmt }

Expressions:
  Expr ::= INT | FLOAT | STRING | true | false
         | IDENT
         | '(' Expr ')'
         | Expr BinOp Expr
         | CallExpr
         | NewExpr
         | ArrayExpr

  CallExpr ::= IDENT '(' [Args] ')'
  NewExpr  ::= 'new' IDENT '(' [Args] ')'
  Args     ::= Expr { ',' Expr }

Binary operators:
  +, -, *, /, ==, !=, <, >, <=, >=

Classes and Methods:
  ClassDecl ::= 'class' IDENT '{' { VarDecl | MethodDecl } '}'
  MethodDecl ::= 'method' IDENT '(' [Params] ')' '{' Seq '}'
  Params     ::= IDENT { ',' IDENT }


3. Type System
--------------

The type system is based on Hindley–Milner polymorphic inference.

Basic types:
  int, float, bool, string, unit, actor

Composite types:
  - Array type:        τ array
  - Function type:     τ1 * τ2 * ... -> τr
  - Polymorphic type:  ∀α. τ
  - Type variables:    'a1, 'a2, ...

Sample types:
  int array                     (array of integers)
  ∀a. a array                   (polymorphic array)
  ∀a. (a array * a) -> a array  (array_push)
  (float, float) -> float       (+ operator)
  string * float -> string      (string concatenation)

Subtyping: None.
Type coercion: Explicit only.
All functions are first-class values.


4. Built-in Primitives
----------------------

Arithmetic:
  sin, cos, tan, asin, acos, atan,
  sqrt, exp, log10, abs, floor, ceil, round
    - type: float -> float

Arithmetic operators:
  +, -, *, /
    - type: float * float -> float

String concatenation:
  + : string * α -> string
  + : α * string -> string

Printing and inspection:
  print   : ∀α. α -> unit
  typeof  : ∀α. α -> string

Array operations:
  array_empty : ∀α. unit -> α array
  array_len   : ∀α. α array -> int
  array_get   : ∀α. α array * int -> α
  array_set   : ∀α. α array * int * α -> α array
  array_push  : ∀α. α array * α -> α array

Example:
  var xs = array_empty();
  xs = array_push(xs, 10);
  xs = array_push(xs, 20);
  print(array_len(xs));   // prints 2
  print(array_get(xs, 0)); // prints 10


5. Actor Model
--------------

Actors encapsulate state and behavior.
An actor can send messages to another actor asynchronously using 'send'.

Actor declaration:
  actor Hello {
    var count = 0;

    behavior init(n) {
      count = n;
      call print("Hello initialized with " + n);
      become greet;
    }

    behavior greet() {
      call print("Hello! count = " + count);
    }
  }

Actor creation and message passing:
  var h = new Hello(5);
  send h.greet();

Each actor executes in its own lightweight thread.
Message passing is asynchronous and non-blocking.


6. Evaluation Model
-------------------

The evaluator (`eval_thread.ml`) implements:
  - Expression evaluation (EVar, EInt, EFloat, EString, EBinop, etc.)
  - Actor message queues
  - Threaded message handling
  - Built-in primitive dispatch through a prim_table
  - Value representation:
      VInt of int
      VFloat of float
      VString of string
      VBool of bool
      VUnit
      VActor of string
      VArray of value array

Expressions are evaluated left-to-right.
Assignment and variable bindings mutate local environment (per actor).


7. Polymorphic Type Inference
-----------------------------

Implemented via `infer.ml`:
  - Uses type variables (TVar of tvar ref)
  - Unification with occurs-check
  - Generalization / instantiation for let-bound variables
  - Overload resolution for polymorphic primitives (e.g., '+')

Core components:
  repr       : find representative type (union-find)
  unify      : unify two types
  occurs     : occurs check
  generalize : ∀ quantification over free type vars
  instantiate: replace quantified vars with fresh ones
  pick_overload : resolve overloaded primitives by type unification


8. Runtime System
-----------------

Execution uses a lightweight actor scheduler implemented with OCaml threads.
Each actor has:
  - an environment (variable table)
  - a message queue
  - an execution behavior (method pointer)

The runtime supports:
  - Asynchronous message delivery
  - Method call ('call') as synchronous procedure invocation
  - 'become' to change current actor behavior


9. Example Program
------------------

class Hello {
  var count = 0;

  method init(n) {
    count = n;
    call print("Hello object initialized with " + n);
  }

  method greet() {
    call print("Hello! count = " + count);
  }

  method inc() {
    count = count + 1;
    call print("count incremented to " + count);
  }
}

var h = new Hello(5);
send h.greet();


10. Grammar Summary
-------------------

Program   ::= { ClassDecl | ActorDecl | Stmt }
Stmt      ::= VarDecl | Assign | CallStmt | SendStmt | Seq
Expr      ::= INT | FLOAT | STRING | IDENT
             | Expr BinOp Expr
             | CallExpr | NewExpr | ArrayExpr
BinOp     ::= '+' | '-' | '*' | '/' | '==' | '!=' | '<' | '<=' | '>' | '>='
ArrayExpr ::= array_empty() | array_push(e1, e2) | array_get(e1, e2) | ...
CallExpr  ::= IDENT '(' [Args] ')'
Args      ::= Expr { ',' Expr }
ClassDecl ::= 'class' IDENT '{' { VarDecl | MethodDecl } '}'
MethodDecl::= 'method' IDENT '(' [Params] ')' '{' Seq '}'
Params    ::= IDENT { ',' IDENT }
ActorDecl ::= 'actor' IDENT '{' BehaviorDecl+ '}'
BehaviorDecl::= 'behavior' IDENT '(' [Params] ')' '{' Seq '}'


11. Implementation Notes
------------------------

- Lexer: implemented with ocamllex
- Parser: implemented with ocamlyacc
- Evaluator: supports threading via OCaml Thread module
- Type inference: Hindley–Milner with polymorphism and overload resolution
- Built-in environment: defined in typing_env.ml (Typing_env.prelude)
- Supported OCaml version: ≥ 4.14.0


12. Future Work
---------------

- Add algebraic data types and pattern matching
- Extend the actor system to support remote messaging
- Introduce modules and namespaces
- Add garbage collection for actors and arrays
- Provide native compilation via Dune + OCamlopt
- Integrate with SDL (tsdl) for visual actor simulation


--------------------------------------------
End of Specification
--------------------------------------------
