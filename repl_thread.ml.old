open Ast
open Eval_thread
open Lexer
open Parser

let script_file = ref None

let speclist = [
  ("-f", Arg.String (fun s -> script_file := Some s), "Script file to execute at startup");
]

let parse_input input =
  let lexbuf = Lexing.from_string input in
  try program read lexbuf
  with _ -> print_endline "[Parse error]"; []

let usage_msg = "Usage: abclrepl_thread [-f script_file]"

let print_tokens input =
  let lexbuf = Lexing.from_string input in
  let rec loop () =
    match read lexbuf with
    | EOF -> print_endline "EOF"
    | token ->
        Printf.printf "Token: %s\n" (match token with
          | ID s -> "ID(" ^ s ^ ")"
          | FLOATLIT f -> "FLOAT(" ^ string_of_float f ^ ")"
          | STRINGLIT s -> "STRING(" ^ s ^ ")"
          | OBJECT -> "OBJECT"
          | METHOD -> "METHOD"
          | FLOAT -> "FLOAT"
          | CALL -> "CALL"
          | SEND -> "SEND"
          | IF -> "IF"
          | THEN -> "THEN"
          | ELSE -> "ELSE"
          | WHILE -> "WHILE"
          | DO -> "DO"
          | EQ -> "EQ"
          | PLUS -> "PLUS"
          | MINUS -> "MINUS"
          | TIMES -> "TIMES"
	  | DIV -> "DIV"
          | LPAREN -> "LPAREN"
          | RPAREN -> "RPAREN"
          | LBRACE -> "LBRACE"
          | RBRACE -> "RBRACE"
          | SEMICOLON -> "SEMICOLON"
          | COMMA -> "COMMA"
          | LE -> "LE"
          | GE -> "GE"
          | EOF -> "EOF");
        loop ()
  in loop ()

let rec string_of_expr = function
  | Float f -> string_of_float f
  | String s -> "\"" ^ s ^ "\""
  | Var v -> v
  | Binop (op, e1, e2) -> "(" ^ string_of_expr e1 ^ " " ^ op ^ " " ^ string_of_expr e2 ^ ")"
  | Call (fname, args) -> fname ^ "(" ^ String.concat ", " (List.map string_of_expr [args]) ^ ")"
  | Expr e -> (string_of_expr e)

let rec string_of_stmt = function
  | Assign (v, e) -> v ^ " = " ^ string_of_expr e
  | CallStmt (fname, args) -> "call " ^ fname ^ "(" ^ String.concat ", " (List.map string_of_expr args) ^ ")"
  | Send (tgt, msg) -> "send " ^ tgt ^ " " ^ msg
  | Seq stmts -> String.concat "; " (List.map string_of_stmt stmts)
  | If (cond, t, f) -> "if " ^ string_of_expr cond ^ " then (" ^ string_of_stmt t ^ ") else (" ^ string_of_stmt f ^ ")"
  | While (cond, body) -> "while " ^ string_of_expr cond ^ " do (" ^ string_of_stmt body ^ ")"
  | VarDecl (vname, e) -> vname ^ " = " ^ string_of_expr e

let string_of_decl = function
  | Class obj ->
    let fields = List.map (fun (n, e) -> "  float " ^ n ^ " = " ^ string_of_expr e) obj.fields in
    let methods = List.map (fun m -> "  method " ^ m.mname ^ "() { " ^ string_of_stmt m.body ^ " }") obj.methods in
    "object " ^ obj.cname ^ " {\n" ^ String.concat "\n" (fields @ methods) ^ "\n}"
  | Instantiate (cls, var) -> cls ^ " " ^ var ^ ";"
  | InstantiateInit (cls, var, inits) ->
    let init_strs = List.map (fun (k, v) -> k ^ " = " ^ string_of_expr v) inits in
    cls ^ " " ^ var ^ " = { " ^ String.concat ", " init_strs ^ " };"

let () =
  Arg.parse speclist (fun _ -> ()) usage_msg;
  match !script_file with
  | Some filename ->
    begin
      try
        let ic = open_in filename in
        try
          while true do
            let line = input_line ic in
            print_endline ("[script] " ^ line);
            (* ここで line を処理する関数を呼び出す *)
            (* 例: process_command line *)
          done
        with End_of_file ->
          close_in ic;
          print_endline "[Script execution completed]"
      with Sys_error msg ->
        Printf.printf "[Error] Could not open script file: %s\n" msg
    end
  | None -> ();
  
  print_endline "ABCL/c+ REPL (type 'exit' to quit)";
  let program_buffer = ref [] in
  let compiled = ref false in
  let process_command line =
    if line = "exit" then exit 0
    else if String.trim line = "" then ()
    else if line = "compile" then (
      compiled := true;
      List.iter (function
        | Class obj -> Printf.printf "[Defined class %s]\n" obj.cname
        | Instantiate (cls, var) ->
            if Hashtbl.mem Eval_thread.actor_table var then
              Printf.printf "[Error] Instance '%s' already exists]\n" var
            else
              (match List.find_opt (function Class c -> c.cname = cls | _ -> false) !program_buffer with
              | Some (Class cobj) ->
                  let obj = { cobj with cname = var } in
                  spawn_actor obj
              | _ -> Printf.printf "[Error] Class %s not found\n" cls)
        | InstantiateInit (cls, var, initvals) ->
            if Hashtbl.mem Eval_thread.actor_table var then
              Printf.printf "[Error] Instance '%s' already exists]\n" var
            else
              (match List.find_opt (function Class c -> c.cname = cls | _ -> false) !program_buffer with
              | Some (Class cobj) ->
                  let obj = { cobj with cname = var; fields = initvals } in
                  spawn_actor obj
              | _ -> Printf.printf "[Error] Class %s not found\n" cls)
      ) !program_buffer;
      print_endline "[Compiled]"
    )
    else if line = "list" then (
      print_endline "Active objects:";
      Hashtbl.iter (fun name _ -> Printf.printf " - %s\n" name) Eval_thread.actor_table
    )
    else if String.length line > 5 && String.sub line 0 5 = "send " then (
      let parts = String.split_on_char '.' (String.sub line 5 (String.length line - 5)) in
      match parts with
      | [obj; meth] -> send_message obj (CallStmt (meth, []))
      | _ -> print_endline "[Error] Invalid send syntax"
    )
    else if String.length line > 4 && String.sub line 0 4 = "run " then (
      let parts = String.split_on_char '.' (String.sub line 4 (String.length line - 4)) in
      match parts with
      | [obj; meth] -> send_message obj (CallStmt (meth, []))
      | _ -> print_endline "[Error] Invalid run syntax"
    )
    else if String.length line > 5 && String.sub line 0 5 = "load " then (
      let filename = String.trim (String.sub line 5 (String.length line - 5)) in
      try
        let ic = open_in_bin filename in
        let len = in_channel_length ic in
        let s = really_input_string ic len in
        close_in ic;
        print_endline "[Token stream]";
        print_tokens s;
        let decls = parse_input s in
        print_endline "[AST]";
        List.iter (fun d -> print_endline (string_of_decl d)) decls;
        program_buffer := !program_buffer @ decls;
        Printf.printf "[Loaded %s]\n" filename
      with _ ->
        Printf.printf "[Error] could not load %s\n" filename
    )
    else if line = "compile" then (
      exit 0;
    )
    else (
      print_endline "[Error] could not found command.\n"
    )
  in
  while true do
    print_string "ABCL/c+ > ";
    flush stdout;
    let line = read_line () in
    if line = "exit" then exit 0
    else if String.trim line = "" then ()
    else if line = "compile" then (
      compiled := true;
      List.iter (function
        | Class obj -> Printf.printf "[Defined class %s]\n" obj.cname
        | Instantiate (cls, var) ->
            if Hashtbl.mem Eval_thread.actor_table var then
              Printf.printf "[Error] Instance '%s' already exists]\n" var
            else
              (match List.find_opt (function Class c -> c.cname = cls | _ -> false) !program_buffer with
              | Some (Class cobj) ->
                  let obj = { cobj with cname = var } in
                  spawn_actor obj
              | _ -> Printf.printf "[Error] Class %s not found\n" cls)
        | InstantiateInit (cls, var, initvals) ->
            if Hashtbl.mem Eval_thread.actor_table var then
              Printf.printf "[Error] Instance '%s' already exists]\n" var
            else
              (match List.find_opt (function Class c -> c.cname = cls | _ -> false) !program_buffer with
              | Some (Class cobj) ->
                  let obj = { cobj with cname = var; fields = initvals } in
                  spawn_actor obj
              | _ -> Printf.printf "[Error] Class %s not found\n" cls)
      ) !program_buffer;
      print_endline "[Compiled]"
    )
    else if line = "list" then (
      print_endline "Active objects:";
      Hashtbl.iter (fun name _ -> Printf.printf " - %s\n" name) Eval_thread.actor_table
    )
    else if line = "vlist" then (
      print_endline "Active objects:";
      Hashtbl.iter (fun name actor ->
        Printf.printf " - %s\n%s" name (Eval_thread.show_actor_env actor)
      ) Eval_thread.actor_table
    )
    else if String.length line > 5 && String.sub line 0 5 = "send " then (
      let parts = String.split_on_char '.' (String.sub line 5 (String.length line - 5)) in
      match parts with
      | [obj; meth] -> send_message obj (CallStmt (meth, []))
      | _ -> print_endline "[Error] Invalid send syntax"
    )
    else if String.length line > 4 && String.sub line 0 4 = "run " then (
      let parts = String.split_on_char '.' (String.sub line 4 (String.length line - 4)) in
      match parts with
      | [obj; meth] -> send_message obj (CallStmt (meth, []))
      | _ -> print_endline "[Error] Invalid run syntax"
    )
    else if String.length line > 5 && String.sub line 0 5 = "load " then (
      let filename = String.trim (String.sub line 5 (String.length line - 5)) in
      try
        let ic = open_in_bin filename in
        let len = in_channel_length ic in
        let s = really_input_string ic len in
        close_in ic;
        print_endline "[Token stream]";
        print_tokens s;
        let decls = parse_input s in
        print_endline "[AST]";
        List.iter (fun d -> print_endline (string_of_decl d)) decls;
        program_buffer := !program_buffer @ decls;
        Printf.printf "[Loaded %s]\n" filename
      with _ ->
        Printf.printf "[Error] could not load %s\n" filename
    )
    else if String.length line > 7 && String.sub line 0 7 = "script " then (
      let filename = String.trim (String.sub line 7 (String.length line - 7)) in
      try
        let ic = open_in filename in
        try
          while true do
            let cmd = input_line ic in
            print_endline ("[script] " ^ cmd);
            process_command cmd
         done
      with End_of_file ->
      close_in ic;
      print_endline "[Script execution completed]"
      with Sys_error msg ->
        Printf.printf "[Error] Could not open script file: %s\n" msg
    )
    else (
      print_tokens line;
      let decls = parse_input line in
      List.iter (fun d -> print_endline (string_of_decl d)) decls;
      program_buffer := !program_buffer @ decls
    )
  done
