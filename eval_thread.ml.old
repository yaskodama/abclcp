open Ast
open Thread
open Mutex
open Sdl_helper

type message = stmt

(* 値の型名を返す *)

type actor = {
  name : string;
  queue : message Queue.t;
  mutex : Mutex.t;
  cond  : Condition.t;
  env   : (string, string) Hashtbl.t;
  methods : (string, stmt) Hashtbl.t;
  mutable last_sender : string;
}

let actor_table : (string, actor) Hashtbl.t = Hashtbl.create 10

(* ===== 1) 値型を拡張 ===== *)
type value =
  | VFloat of float
  | VString of string
  | VBool of bool
  | VUnit

(* ===== 2) 環境 ===== *)
let env : (string, value) Hashtbl.t = Hashtbl.create 64

let get_var x =
  try Hashtbl.find env x
  with Not_found -> failwith ("unbound variable: " ^ x)

let set_var x v =
  Hashtbl.replace env x v

(* ===== 3) 真偽判定（互換） ===== *)
let to_bool = function
  | VBool b -> b
  | VFloat f -> f <> 0.0
  | VString s -> failwith ("string is not allowed as condition: " ^ s)
  | VUnit -> false

(* ===== 4) 二項演算 ===== *)
let as_float = function
  | VFloat f -> f
  | _ -> failwith "expected float"

let as_string = function
  | VString s -> s
  | _ -> failwith "expected string"

let apply_binop op v1 v2 =
  match op, v1, v2 with
  (* 数値演算 *)
  | ("+"|"-"|"*"|"/"), _, _ ->
      let a = as_float v1 and b = as_float v2 in
      VFloat (match op with
        | "+" -> a +. b | "-" -> a -. b
        | "*" -> a *. b | "/" -> a /. b
        | _ -> assert false)
  (* 比較（float -> bool） *)
  | (">"|">="|"<"|"<="|"=="|"!="), _, _ ->
      let a = as_float v1 and b = as_float v2 in
      VBool (match op with
        | ">"  -> a >  b | ">=" -> a >= b
        | "<"  -> a <  b | "<=" -> a <= b
        | "==" -> a =  b | "!=" -> a <> b
        | _ -> assert false)
  (* 文字列連結を許可したい場合はこの1行を有効化 *)
  (*
  | "+", VString s1, VString s2 -> VString (s1 ^ s2)
  *)
  | _ ->
      failwith ("unsupported binop/operands: " ^ op)

(* === Actor-aware wrappers === *)
(* 既存の get_var : string -> value / set_var : string -> value -> unit を壊さず、
   将来 actor.env に切り替えるときはここの中身だけ差し替えればOK。 *)

let get_var_a (actor:actor) (x:string) : value =
  let _ = actor in
  get_var x

let set_var_a (actor:actor) (x:string) (v:value) : unit =
  let _ = actor in
  set_var x v

(* === Value extractors === *)
let as_float = function
  | VFloat f -> f
  | v -> failwith (Printf.sprintf "expected float, got %s"
                     (match v with VString _->"string"|VBool _->"bool"|VUnit->"unit"|VFloat _->"float"))

let as_string = function
  | VString s -> s
  | v -> failwith (Printf.sprintf "expected string, got %s"
                     (match v with VFloat _->"float"|VBool _->"bool"|VUnit->"unit"|VString _->"string"))

let create_actor name =
  {
    name;
    queue = Queue.create ();
    mutex = Mutex.create ();
    cond = Condition.create ();
    env = Hashtbl.create 10;
    methods = Hashtbl.create 10;
    last_sender = "";
  }

let send_message ~from target_name msg =
  let log_message () =
    let oc = open_out_gen [Open_creat; Open_append; Open_text] 0o644 "message_log.txt" in
    Printf.fprintf oc "[SEND] to %s: %s\n" target_name
      (match msg with CallStmt(m,_) -> m | _ -> "stmt");
    close_out oc
  in
  log_message ();
  match Hashtbl.find_opt actor_table target_name with
  | Some actor ->
      Mutex.lock actor.mutex;
      actor.last_sender <- from;
      Queue.push msg actor.queue;
      Condition.signal actor.cond;
      Mutex.unlock actor.mutex
  | None ->
      Printf.printf "Actor %s not found\n" target_name

let prim_typeof =
  ("typeof", function
     | [VFloat _]  -> VString "float"
     | [VString _] -> VString "string"
     | [VBool _]   -> VString "bool"
     | [VUnit]     -> VString "unit"
     | _ -> failwith "typeof: expected exactly one argument")

(* ===== 5) 組み込み関数 ===== *)
let prim1_float_float name f = (name, function
  | [VFloat x] -> VFloat (f x)
  | _ -> failwith (name ^ ": expected (float)"))

let prim1_print =
  ("print", function
     | [VString s] -> print_endline s; VUnit
     | [VFloat  f] -> print_endline (string_of_float f); VUnit
     | [VBool   b] -> print_endline (if b then "true" else "false"); VUnit
     | [VUnit]     -> print_endline "()"; VUnit
     | _ -> failwith "print: expected (string|float|bool|unit)")

let prim_table : (string, value list -> value) Hashtbl.t =
  let h = Hashtbl.create 32 in
  let add (n,f) = Hashtbl.replace h n f in
  List.iter add [
    prim1_float_float "sin" sin;
    prim1_float_float "cos" cos;
    prim1_float_float "tan" tan;
    prim1_float_float "asin" asin;
    prim1_float_float "acos" acos;
    prim1_float_float "atan" atan;
    prim1_float_float "sqrt" sqrt;
    prim1_float_float "exp" exp;
    prim1_float_float "log10" (fun x -> log10 x);
    prim1_float_float "abs" abs_float;
    prim1_float_float "floor" (fun x -> floor x);
    prim1_float_float "ceil" (fun x -> ceil x);
    prim1_float_float "round" (fun x -> Float.round x);
    prim1_print;
    prim_typeof;
  ];
  h

let call_prim name args =
  match Hashtbl.find_opt prim_table name with
  | Some f -> f args
  | None ->
      (* ★ 登録されているプリミティブ一覧を出す *)
      print_endline "[debug] prim_table keys:";
      Hashtbl.iter (fun k _ -> print_endline ("  - " ^ k)) prim_table;
      failwith ("Unknown function: " ^ name)

(* ===== 6) 式の評価（actor あり版） ===== *)
let rec eval_expr (actor:actor) = function
  | Float f  -> VFloat f
  | String s -> VString s
  | Var x    -> get_var_a actor x
  | Binop (op, e1, e2) ->
      let v1 = eval_expr actor e1 in
      let v2 = eval_expr actor e2 in
      apply_binop op v1 v2
  | Call (fname, arg1) ->
      let v = eval_expr actor arg1 in
      call_prim fname [v]
  | Expr e -> eval_expr actor e

(*
let rec eval_expr env = function
  | Float f -> f
  | String _ -> 0.0
  | Var v -> float_of_string (Hashtbl.find env v)
  | Binop ("+", e1, e2) -> eval_expr env e1 +. eval_expr env e2
  | Binop ("-", e1, e2) -> eval_expr env e1 -. eval_expr env e2
  | Binop ("*", e1, e2) -> eval_expr env e1 *. eval_expr env e2
  | Binop ("/", e1, e2) -> eval_expr env e1 /. eval_expr env e2
  | Binop (">=", e1, e2) -> 1.0
  | Call (fname, args) ->
      let arg_vals = List.map (eval_expr env) [args] in
      (match fname, arg_vals with
       | "sin", [x] -> sin x
       | "cos", [x] -> cos x
       | "tan", [x] -> tan x
       | "asin", [x] -> asin x
       | "acos", [x] -> acos x
       | "atan", [x] -> atan x
       | "sqrt", [x] -> sqrt x
       | "exp", [x] -> exp x
       | "log10", [x] -> log10 x
       | "abs", [x] -> abs_float x
       | "floor", [x] -> floor x
       | "ceil", [x] -> ceil x
       | "round", [x] -> Float.round x
       | "typeof", [x] -> prim_typeof x
       | _ -> failwith ("Unknown function: " ^ fname))
  | Expr e -> eval_expr env e
  | _ -> failwith "unsupported expr-1"
*)

let wait_ms ms =
   let seconds = ms /. 1000.0 in
   ignore (Unix.select [] [] [] seconds)

(* ===== 7) 文の評価（actor あり版） ===== *)
let rec eval_stmt (actor:actor) = function
  | Assign (x, e) ->
      set_var_a actor x (eval_expr actor e)
  | VarDecl (name, rhs) ->
      set_var_a actor name (eval_expr actor rhs)
  | If (cond, tbr, fbr) ->
      if to_bool (eval_expr actor cond)
      then eval_stmt actor tbr
      else eval_stmt actor fbr
  | While (cond, body) ->
      while to_bool (eval_expr actor cond) do
        eval_stmt actor body
      done
  | Seq ss ->
      List.iter (eval_stmt actor) ss
  (* SDL primitives: eval_expr actor で評価→float にしてから呼ぶ *)
  | CallStmt ("sdl_init", [w; h]) ->
      let w = int_of_float (as_float (eval_expr actor w))
      and h = int_of_float (as_float (eval_expr actor h)) in
      Sdl_helper.sdl_init ~w ~h ~title:"ABCL/c+"
  | CallStmt ("sdl_clear", []) ->
      Sdl_helper.sdl_clear ()
  | CallStmt ("sdl_line", [x1; y1; x2; y2]) ->
      let x1 = int_of_float (as_float (eval_expr actor x1))
      and y1 = int_of_float (as_float (eval_expr actor y1))
      and x2 = int_of_float (as_float (eval_expr actor x2))
      and y2 = int_of_float (as_float (eval_expr actor y2)) in
      Sdl_helper.sdl_draw_line x1 y1 x2 y2
  | CallStmt ("sdl_present", []) ->
      Sdl_helper.sdl_present ()
  | CallStmt ("sdl_erase_line", [e1; e2; e3; e4]) ->
      let x1 = int_of_float (as_float (eval_expr actor e1))
      and y1 = int_of_float (as_float (eval_expr actor e2))
      and x2 = int_of_float (as_float (eval_expr actor e3))
      and y2 = int_of_float (as_float (eval_expr actor e4)) in
      Sdl_helper.sdl_erase_line x1 y1 x2 y2
  (* その他のプリミティブは prim_table に委譲 *)
  | CallStmt (fname, args) ->
      let vs = List.map (eval_expr actor) args in
      ignore (call_prim fname vs)
  | Send (_tgt, _meth, args) ->
      ignore (List.map (eval_expr actor) args)

(*
let rec eval_stmt (actor:actor) = function
  | Assign (x, e) -> set_var ~actor x (eval_expr actor e)
  | VarDecl (x, e) -> set_var ~actor x (eval_expr actor e)
  | If (c,t,f) -> if to_bool (eval_expr actor c) then eval_stmt actor t else eval_stmt actor f
  | While (c,b) -> while to_bool (eval_expr actor c) do eval_stmt actor b done
  | Seq ss -> List.iter (eval_stmt actor) ss
  | CallStmt (fname, args) ->
      let vs = List.map (eval_expr actor) args in
      ignore (call_prim fname vs)
  | Send (_tgt,_meth,args) -> ignore (List.map (eval_expr actor) args)
*)

(*
let rec eval_stmt actor stmt =
  match stmt with
  | Assign (v, e) ->
      let f = eval_expr actor.env e in
      Hashtbl.replace actor.env v (string_of_float f)
  | CallStmt ("print", [e]) ->
      (match e with
       | String s -> Printf.printf "[%s] %s\n%!" actor.name s
       | _ -> let f = eval_expr actor.env e in Printf.printf "[%s] %f\n%!" actor.name f)
  | CallStmt ("wait", [e]) -> wait_ms (eval_expr actor.env e)
  | CallStmt ("sdl_init", [w; h]) ->
    let w = int_of_float (eval_expr actor.env w)
    and h = int_of_float (eval_expr actor.env h) in
    Sdl_helper.sdl_init ~w ~h ~title:"ABCL/c+"
  | CallStmt ("sdl_clear", []) ->
    Sdl_helper.sdl_clear ()
  | CallStmt ("sdl_line", [x1; y1; x2; y2]) ->
    let x1 = int_of_float (eval_expr actor.env x1)
    and y1 = int_of_float (eval_expr actor.env y1)
    and x2 = int_of_float (eval_expr actor.env x2)
    and y2 = int_of_float (eval_expr actor.env y2) in
    Sdl_helper.sdl_draw_line x1 y1 x2 y2
  | CallStmt ("sdl_present", []) ->
    Sdl_helper.sdl_present ()
  | CallStmt ("sdl_erase_line", [e1; e2; e3; e4]) ->
    let x1 = int_of_float (eval_expr actor.env e1)
    and y1 = int_of_float (eval_expr actor.env e2)
    and x2 = int_of_float (eval_expr actor.env e3)
    and y2 = int_of_float (eval_expr actor.env e4) in
    Sdl_helper.sdl_erase_line x1 y1 x2 y2
  | CallStmt (mname, _actual_args) -> 
    (match Hashtbl.find_opt actor.methods mname with
     | Some body -> eval_stmt actor body
     | None ->
         Printf.printf "[%s] method not found: %s\n" actor.name mname)
  | CallStmt (_, _) -> print_endline "Unsupported call args"
  | Send (tgt, meth, args) ->
    let actual_target =
      if tgt = "self" then actor.name
      else if tgt = "sender" then actor.last_sender
      else tgt
    in
    let arg_vals = List.map (eval_expr actor.env) args in
    let expr_args = List.map (fun f -> Float f) arg_vals in
    send_message ~from:actor.name actual_target (CallStmt (meth, expr_args))
  | Seq stmts -> List.iter (eval_stmt actor) stmts
  | If (cond, t_branch, f_branch) ->
      if eval_expr actor.env cond <> 0.0 then eval_stmt actor t_branch
      else eval_stmt actor f_branch
  | While (cond, body) ->
      while eval_expr actor.env cond <> 0.0 do
        eval_stmt actor body
      done
  | VarDecl (name, expr) ->
      let value = eval_expr actor.env expr in
      Hashtbl.add actor.env name (string_of_float value)
*)

let actor_loop actor =
  let log_queue () =
    let oc = open_out_gen [Open_creat; Open_append; Open_text] 0o644 ("queue_" ^ actor.name ^ ".txt") in
    Queue.iter (fun msg ->
      match msg with
      | CallStmt (m, _) -> Printf.fprintf oc "[%s] %s\n" actor.name m
      | _ -> Printf.fprintf oc "[%s] stmt\n" actor.name
    ) actor.queue;
    close_out oc
  in
  while true do
    Mutex.lock actor.mutex;
    while Queue.is_empty actor.queue do
      Condition.wait actor.cond actor.mutex
    done;
    let msg = Queue.pop actor.queue in
    log_queue ();
    Mutex.unlock actor.mutex;
    eval_stmt actor msg
  done

let spawn_actor obj =
  let actor = create_actor obj.cname in
(*  Printf.printf "[spawn_actor] creating actor: %s\n" obj.cname;
  print_endline "  with fields:";
  List.iter (fun (k, v) ->
    Printf.printf "    %s = %s\n" k
      (match v with
       | Float f -> string_of_float f
       | String s -> "\"" ^ s ^ "\""
       | Var x -> x
       | Binop (_, _, _) -> "<binop>"
       | Call (_, _) -> "<call>")
  ) obj.fields; *)
  List.iter (fun (VarDecl(k, v)) ->
    match v with
    | Float f -> Hashtbl.replace actor.env k (string_of_float f)
    | String s -> Hashtbl.replace actor.env k s
    | _ -> ()
  ) obj.fields;
(*  print_endline ("----[Actor created] " ^ obj.cname ^ " with variables:");
  Hashtbl.iter (fun key value ->
    Printf.printf "  %s = %s\n" key value
  ) actor.env; *)
  (* 2. InstantiateInit 用の初期化フィールドがあれば上書き *)
  (match obj with
  | { fields = initvals; _ } ->
    List.iter (fun (VarDecl(k, v)) ->
      match v with
      | Float f -> Hashtbl.replace actor.env k (string_of_float f)
      | String s -> Hashtbl.replace actor.env k s
      | _ -> ()
    ) initvals
  );
  print_endline ("----[Actor created] " ^ obj.cname ^ " with variables:");
  Hashtbl.iter (fun key value ->
    Printf.printf "  %s = %s\n" key value
  ) actor.env;
  List.iter (fun m -> Hashtbl.replace actor.methods m.mname m.body) obj.methods;
  Hashtbl.add actor_table obj.cname actor;
  ignore (Thread.create (fun () -> actor_loop actor) ())

let show_actor_env actor =
  Hashtbl.fold (fun key value acc ->
    acc ^ Printf.sprintf "   %s = %s\n" key value
  ) actor.env ""

(* 既存が float ベースのときにあった value = float 等の定義は削除/置換 *)
(* ===== 6) 式の評価 ===== *)
(* open Ast *)

(*
let rec eval_expr = function
  | Float f -> VFloat f
  | String s -> VString s
  | Var x -> get_var x
  | Binop (op, e1, e2) ->
      let v1 = eval_expr e1 in
      let v2 = eval_expr e2 in
      apply_binop op v1 v2
  | Call (fname, arg1) ->
      let v = eval_expr arg1 in
      call_prim fname [v]
  | Expr e -> eval_expr e
*)
(*
let rec eval_stmt = function
  | Assign (x, e) ->
      let v = eval_expr e in
      set_var x v
  | VarDecl (name, rhs) ->
      let v = eval_expr rhs in
      set_var name v
  | If (cond, tbr, fbr) ->
      if to_bool (eval_expr cond)
      then eval_stmt tbr
      else eval_stmt fbr
  | While (cond, body) ->
      while to_bool (eval_expr cond) do
        eval_stmt body
      done
  | Seq ss ->
      List.iter eval_stmt ss
  | CallStmt (fname, args) ->
      let vs = List.map eval_expr args in
      ignore (call_prim fname vs)
  | Send (tgt, meth, args) ->
      (* 送信ターゲット/引数を評価だけして、実際の送信は既存実装に委譲する場合の最小形 *)
      let _ = eval_expr (Var tgt) in
      let _ = meth in
      let _ = List.map eval_expr args in
      ()
*)
