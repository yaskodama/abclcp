(** infer.ml *)
open Types
open Typing_env
open Ast

(* ========================================= *)
(* 名前に対応する全スキームを取得する関数   *)
(* ========================================= *)

let find_all (env : (string, scheme list) Hashtbl.t) (name : string) : scheme list =
  match Hashtbl.find_opt env name with
  | Some schemes -> schemes
  | None -> []

let ty_of_binop_as_function (op:string) : ty option =
  (* Binop は「関数」のオーバーロードとして env にも入れているので、ここでは補助的に *)
  match op with
  | _ -> None

let pick_overload (name:string) (env:tenv) (arg_tys:ty list) : ty =
  let schemes =
    match Hashtbl.find_opt env name with Some ss -> ss | None -> []
  in
  let ok =
    List.filter_map (fun sch ->
      match repr (instantiate sch) with
      | TFun (ps, ret) when List.length ps = List.length arg_tys ->
          (try List.iter2 unify ps arg_tys; Some (repr ret)
           with _ -> None)
      | _ -> None
    ) schemes
  in
  match ok with
  | [r] -> r
  | r::_ -> r     (* 単一に絞れない場合の方針は実装に合わせて *)
  | [] ->
      let sigstr =
        "(" ^ String.concat ", " (List.map string_of_ty arg_tys) ^ ")"
      in
      raise (Type_error ("no overload of "^name^" matches "^sigstr))

(*
let pick_overload (fname:string) (env: (string, scheme list) Hashtbl.t) (arg_tys: ty list) : ty =
  let candidates = lookup_schemes fname in
  let ok =
    List.filter_map (fun (Forall _ as sch) ->
      let t = instantiate sch in
      match repr t with
      | TFun (ps, ret) when List.length ps = List.length arg_tys ->
          (try
              List.iter2 unify ps arg_tys;
              Some (repr ret)
            with _ -> None)
      | _ -> None
    ) candidates
  in
  match ok with
  | r :: _ -> r
  | [] ->
      let sigstr =
        "(" ^ (String.concat ", " (List.map Types.string_of_ty arg_tys)) ^ ")"
      in
      raise (Types.Type_error ("no outstanding overload of " ^ fname ^ " matches " ^ sigstr))
*)

(* let pick_overload (name:string) (env:env) (arg_tys:ty list) : ty =
  let cands = find_all env name in
  let matches = ref [] in
  List.iter (fun sch ->
    let tf = instantiate sch |> repr in
    match tf with
    | TFun (ps, ret) when List.length ps = List.length arg_tys ->
        (* 引数毎に単一化を試す。失敗したら次の候補。 *)
        let snapshot = clone env in
        (* 型変数 Link を巻き戻す手段が無いので、単一化は型だけに作用。
           ここでは「試行」で失敗しても他候補に影響しないよう、arg/ps を repr で都度評価。 *)
        try
          List.iter2 unify ps arg_tys;
          matches := (ret) :: !matches
        with _ ->
          (* 候補失敗。何もしない *)
          ()
      | _ -> ()
  ) cands;
  match !matches with
  | [ret] -> ret
  | [] ->
      let msg =
        Printf.sprintf "no overload of %s matches (%s)"
          name (String.concat ", " (List.map string_of_ty arg_tys))
      in
      raise (Type_error msg)
  | _ ->
      let msg =
        Printf.sprintf "ambiguous overload of %s for (%s)"
          name (String.concat ", " (List.map string_of_ty arg_tys))
      in
      raise (Type_error msg)
*)

let rec infer_expr (env:env) (e:expr) : ty =
  match e with
  | Int _ -> TInt
  | Float _ -> TFloat
  | String _ -> TString
  | Binop (op, e1, e2) ->
    let t1 = infer_expr env e1 in
    let t2 = infer_expr env e2 in
    (* 特例: 片側が string の + は文字列連結として扱う *)
    (match op, repr t1, repr t2 with
     | "+", TString, _ -> TString
     | "+", _, TString -> TString
     | _ ->
         (* 従来のオーバーロード解決 *)
         pick_overload op env [t1; t2])
  | Call (fname, arg1) ->
      let t_args = List.map (infer_expr env) arg1 in
      pick_overload fname env t_args
  | Expr e -> infer_expr env e
  | Var x ->
      begin match find_all env x with
      | [] -> raise (Type_error ("unbound variable: " ^ x))
      | [sch] -> instantiate sch |> repr
      | schs ->
          let n = List.length schs in
          raise (Type_error (Printf.sprintf
            "ambiguous name: %s has %d overloads" x n))
      end
  | New (cls, args) ->
    List.iter (fun a -> ignore (infer_expr env a)) args;
    TObject cls

let set (e:env) (name:string) (sch:scheme) =
  Hashtbl.replace e name [sch]

let rec check_stmt (env:env) (s:stmt) : unit =
  match s with
  | Assign (x, e) ->
      let te = infer_expr env e in
      (* 代入先が既知なら単一化、未知ならその型に確定。 *)
      begin match find_all env x with
      | [Forall ([], t0)] ->
          unify t0 te
      | [] ->
          (* ここは単相変数として固定する：将来 let 導入時に generalize へ *)
          Typing_env.add env x (Forall ([], te))
      | _ ->
          raise (Type_error ("cannot assign to overloaded name: " ^ x))
      end
  | VarDecl (name, rhs) ->
      let t   = infer_expr env rhs in
      let sch = generalize env t in
      (* 単一束縛として“置き換え” *)
        set env name sch
  | If (cond, tbr, fbr) ->
      (* 現実装互換: 条件は float（0/非0）扱い。将来 Bool にするならここを TBool へ。 *)
      let tc = infer_expr env cond in
      unify tc TFloat;
      check_stmt env tbr; check_stmt env fbr
  | While (cond, body) ->
      let tc = infer_expr env cond in
      unify tc TFloat;
      check_stmt env body
  | Seq ss -> List.iter (check_stmt env) ss
  | CallStmt (fname, args) ->
      let arg_tys = List.map (infer_expr env) args in
      ignore (pick_overload fname env arg_tys);
      ()
  | Send (_tgt, _meth, args) ->
      (* まずは送信引数は float と仮定。将来、クラスのメソッド表を env に載せて精密化 *)
      List.iter (fun a -> unify (infer_expr env a) TFloat) args
  | SSend (_cls, _meth, _args) -> ()   (* TODO: 必要なら精密化 *)
  | _ -> ()                            (* フォールバックで静かにする *)

(* ---- shallow clone for env (string -> scheme list) ---- *)
let clone (e : (string, scheme list) Hashtbl.t) : (string, scheme list) Hashtbl.t =
  let e' = Hashtbl.create (Hashtbl.length e) in
  Hashtbl.iter (fun k v -> Hashtbl.replace e' k v) e;
  e'

let check_decl (env:env) = function
  | Class c ->
      (* 1) フィールドを env に載せる（既存でOK） *)
      List.iter (function
        | VarDecl (name, init) ->
            let t   = infer_expr env init in
            let sch = generalize env t in
            add env name sch
        | _ -> ()
      ) c.fields;

      (* 2) メソッド名を「float^n -> unit」として env に先に登録 *)
      List.iter (fun m ->
        let param_count =
          try List.length (Obj.magic m.params : string list) with _ -> 0
        in
        let ft = TFun (List.init param_count (fun _ -> TFloat), TUnit) in
        add env m.mname (Forall ([], ft))
      ) c.methods;

      (* 3) 本文は“ローカル環境”で検査：ローカル変数が外へ漏れない *)
        List.iter (fun m ->
          let env_m = clone env in
          (* ★ 追加：メソッド仮引数をローカル環境に束縛（型は float 想定） *)
            List.iter (fun p ->
              set env_m p (Forall ([], TFloat))
            ) m.params;
            check_stmt env_m m.body
        ) c.methods
  | Instantiate (_obj, _class) -> ()
  | InstantiateInit (_obj, _class, inits) ->
    List.iter (fun st ->
      match st with
      | VarDecl (_f, e) -> ignore (infer_expr env e)
      | _ -> ()
    ) inits
(*      List.iter (fun (VarDecl(_f, e)) -> ignore (infer_expr env e)) inits     *)
  | InstantiateArgs (_cls, _var, args) ->             (* ★ 追加 *)
      List.iter (fun a -> unify (infer_expr env a) TFloat) args
  | Global s ->                           (* ★ 追加 *)
      check_stmt env s

let check_program (p:program) : (Typing_env.env, string) result =
  let env = Typing_env.prelude () in
  try
    List.iter (check_decl env) p;
    Ok env
  with
  | Type_error msg -> Error msg
